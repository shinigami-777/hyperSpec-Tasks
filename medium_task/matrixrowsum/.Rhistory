# Get unique states and rules
states <- unique(c(edges$state1, edges$state2))
nodes <- data.frame(state = states, y = seq_along(states))
# Add a column for visualization x-coordinates
'''
nodes$x <- 1
# Prepare edges data for plotting
edges_plot <- merge(
x = nodes, y = edges,
by.x = "state", by.y = "state1",
all.x = FALSE, all.y = TRUE
)
edges_plot <- merge(
x = edges_plot, y = nodes,
by.x = "state2", by.y = "state",
suffixes = c("_start", "_end"),
all.x = FALSE, all.y = TRUE
)
# Plot using ggplot2
ggplot(data = nodes, aes(x = x, y = y)) +
# Draw edges as arrows
geom_segment(
data = edges_plot,
aes(
x = x_start, y = y_start, xend = x + 1, yend = y_end,
color = type
),
arrow = arrow(length = unit(0.2, "cm"))
) +
# Add nodes
geom_point(color = "black", size = 3) +
# Add labels for nodes
geom_text(aes(label = state), vjust = -1, size = 3) +
# Customize theme
theme_minimal() +
labs(
x = "Position",
y = "State",
title = "Graph Visualization"
) +
theme(panel.grid = element_blank())
'''
plotModel(simple_graph)
# Define the plotModel function
plotModel2 <- function(graph) {
# Extract edges, their states (from, to), and rules if available
edges <- graph$edges
# Get unique states and rules
states <- unique(c(edges$state1, edges$state2))
nodes <- data.frame(state = states, y = seq_along(states))
# Add a column for visualization x-coordinates
'''
nodes$x <- 1
# Prepare edges data for plotting
edges_plot <- merge(
x = nodes, y = edges,
by.x = "state", by.y = "state1",
all.x = FALSE, all.y = TRUE
)
edges_plot <- merge(
x = edges_plot, y = nodes,
by.x = "state2", by.y = "state",
suffixes = c("_start", "_end"),
all.x = FALSE, all.y = TRUE
)
# Plot using ggplot2
ggplot(data = nodes, aes(x = x, y = y)) +
# Draw edges as arrows
geom_segment(
data = edges_plot,
aes(
x = x_start, y = y_start, xend = x + 1, yend = y_end,
color = type
),
arrow = arrow(length = unit(0.2, "cm"))
) +
# Add nodes
geom_point(color = "black", size = 3) +
# Add labels for nodes
geom_text(aes(label = state), vjust = -1, size = 3) +
# Customize theme
theme_minimal() +
labs(
x = "Position",
y = "State",
title = "Graph Visualization"
) +
theme(panel.grid = element_blank())
'''
}
plotModel2(simple_graph)
# Define the plotModel function
plotModel2 <- function(graph) {
# Extract edges, their states (from, to), and rules if available
edges <- graph$edges
# Get unique states and rules
states <- unique(c(edges$state1, edges$state2))
nodes <- data.frame(state = states, y = seq_along(states))
# Add a column for visualization x-coordinates
'''
nodes$x <- 1
# Prepare edges data for plotting
edges_plot <- merge(
x = nodes, y = edges,
by.x = "state", by.y = "state1",
all.x = FALSE, all.y = TRUE
)
edges_plot <- merge(
x = edges_plot, y = nodes,
by.x = "state2", by.y = "state",
suffixes = c("_start", "_end"),
all.x = FALSE, all.y = TRUE
)
# Plot using ggplot2
ggplot(data = nodes, aes(x = x, y = y)) +
# Draw edges as arrows
geom_segment(
data = edges_plot,
aes(
x = x_start, y = y_start, xend = x + 1, yend = y_end,
color = type
),
arrow = arrow(length = unit(0.2, "cm"))
) +
# Add nodes
geom_point(color = "black", size = 3) +
# Add labels for nodes
geom_text(aes(label = state), vjust = -1, size = 3) +
# Customize theme
theme_minimal() +
labs(
x = "Position",
y = "State",
title = "Graph Visualization"
) +
theme(panel.grid = element_blank())
'''
plotModel2(simple_graph)
# Define the plotModel function
plotModel2 <- function(graph) {
# Extract edges, their states (from, to), and rules if available
edges <- graph$edges
# Get unique states and rules
states <- unique(c(edges$state1, edges$state2))
nodes <- data.frame(state = states, y = seq_along(states))
# Add a column for visualization x-coordinates
'''
nodes$x <- 1
# Prepare edges data for plotting
edges_plot <- merge(
x = nodes, y = edges,
by.x = "state", by.y = "state1",
all.x = FALSE, all.y = TRUE
)
edges_plot <- merge(
x = edges_plot, y = nodes,
by.x = "state2", by.y = "state",
suffixes = c("_start", "_end"),
all.x = FALSE, all.y = TRUE
)
# Plot using ggplot2
ggplot(data = nodes, aes(x = x, y = y)) +
# Draw edges as arrows
geom_segment(
data = edges_plot,
aes(
x = x_start, y = y_start, xend = x + 1, yend = y_end,
color = type
),
arrow = arrow(length = unit(0.2, "cm"))
) +
# Add nodes
geom_point(color = "black", size = 3) +
# Add labels for nodes
geom_text(aes(label = state), vjust = -1, size = 3) +
# Customize theme
theme_minimal() +
labs(
x = "Position",
y = "State",
title = "Graph Visualization"
) +
theme(panel.grid = element_blank())
'''
plotModel2(simple_graph)
# Define the plotModel function
plotModel2 <- function(graph) {
# Extract edges, their states (from, to), and rules if available
edges <- graph$edges
# Get unique states and rules
states <- unique(c(edges$state1, edges$state2))
nodes <- data.frame(state = states, y = seq_along(states))
# Add a column for visualization x-coordinates
nodes$x <- 1
# Prepare edges data for plotting
edges_plot <- merge(
x = nodes, y = edges,
by.x = "state", by.y = "state1",
all.x = FALSE, all.y = TRUE
)
edges_plot <- merge(
x = edges_plot, y = nodes,
by.x = "state2", by.y = "state",
suffixes = c("_start", "_end"),
all.x = FALSE, all.y = TRUE
)
# Plot using ggplot2
ggplot(data = nodes, aes(x = x, y = y)) +
# Draw edges as arrows
geom_segment(
data = edges_plot,
aes(
x = x_start, y = y_start, xend = x + 1, yend = y_end,
color = type
),
arrow = arrow(length = unit(0.2, "cm"))
) +
# Add nodes
geom_point(color = "black", size = 3) +
# Add labels for nodes
geom_text(aes(label = state), vjust = -1, size = 3) +
# Customize theme
theme_minimal() +
labs(
x = "Position",
y = "State",
title = "Graph Visualization"
) +
theme(panel.grid = element_blank())
}
plotModel2(simple_graph)
plotModel2(simple_graph)
# Load required libraries
library(gfpop)
library(ggplot2)
# Define the plotModel function
plotModel <- function(graph) {
# Extract the edges from the gfpop::graph object
edges <- graph$edges
if (nrow(edges) == 0) {
stop("The graph has no edges to plot.")
}
# Get all unique states (state1 and state2)
states <- unique(c(edges$state1, edges$state2))
# Create a node data frame with unique states
nodes <- data.frame(
state = states,
id = seq_along(states)
)
# Add x and y coordinates for nodes
nodes$y <- nodes$id
nodes$x <- 1
# Match edges with node positions
edges_plot <- merge(edges, nodes, by.x = "state1", by.y = "state")
colnames(edges_plot)[colnames(edges_plot) == "x"] <- "x_start"
colnames(edges_plot)[colnames(edges_plot) == "y"] <- "y_start"
edges_plot <- merge(edges_plot, nodes, by.x = "state2", by.y = "state")
colnames(edges_plot)[colnames(edges_plot) == "x"] <- "x_end"
colnames(edges_plot)[colnames(edges_plot) == "y"] <- "y_end"
# Create the plot using ggplot2
ggplot() +
# Add edges as arrows
geom_segment(
data = edges_plot,
aes(x = x_start, y = y_start, xend = x_end, yend = y_end, color = type),
arrow = arrow(length = unit(0.2, "cm"))
) +
# Add nodes as points
geom_point(
data = nodes,
aes(x = x, y = y),
color = "black",
size = 3
) +
# Add labels to nodes
geom_text(
data = nodes,
aes(x = x, y = y, label = state),
vjust = -1
) +
# Customize the theme
theme_minimal() +
labs(
x = "Position",
y = "State",
title = "Graph Visualization"
) +
theme(panel.grid = element_blank())
}
# Define the simple_graph
simple_graph <- gfpop::graph(
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "normal", state2 = "normal", type = "std", penalty = 5.5),
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "noChange", state2 = "noChange", type = "null")
)
# Use the plotModel function
plotModel(simple_graph)
# Define the plotModel function
plotModel <- function(graph) {
# Extract the edges from the gfpop::graph object using the correct method
edges <- as.data.frame(graph)
# Check if edges exist in the graph
if (nrow(edges) == 0) {
stop("The graph has no edges to plot.")
}
# Get all unique states (state1 and state2)
states <- unique(c(edges$state1, edges$state2))
# Create a node data frame with unique states
nodes <- data.frame(
state = states,
id = seq_along(states)
)
# Add x and y coordinates for nodes
nodes$y <- nodes$id
nodes$x <- 1
# Match edges with node positions
edges_plot <- merge(edges, nodes, by.x = "state1", by.y = "state")
colnames(edges_plot)[colnames(edges_plot) == "x"] <- "x_start"
colnames(edges_plot)[colnames(edges_plot) == "y"] <- "y_start"
edges_plot <- merge(edges_plot, nodes, by.x = "state2", by.y = "state")
colnames(edges_plot)[colnames(edges_plot) == "x"] <- "x_end"
colnames(edges_plot)[colnames(edges_plot) == "y"] <- "y_end"
# Create the plot using ggplot2
ggplot() +
# Add edges as arrows
geom_segment(
data = edges_plot,
aes(x = x_start, y = y_start, xend = x_end, yend = y_end, color = type),
arrow = arrow(length = unit(0.2, "cm"))
) +
# Add nodes as points
geom_point(
data = nodes,
aes(x = x, y = y),
color = "black",
size = 3
) +
# Add labels to nodes
geom_text(
data = nodes,
aes(x = x, y = y, label = state),
vjust = -1
) +
# Customize the theme
theme_minimal() +
labs(
x = "Position",
y = "State",
title = "Graph Visualization"
) +
theme(panel.grid = element_blank())
}
# Define the simple_graph
Edge(state1 = "normal", state2 = "normal
# Define the plotModel function
plotModel <- function(graph) {
# Extract the edges from the gfpop::graph object using the correct method
edges <- as.data.frame(graph)
# Check if edges exist in the graph
if (nrow(edges) == 0) {
stop("The graph has no edges to plot.")
# Define the simple_graph
simple_graph <- gfpop::graph(
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "normal", state2 = "normal", type = "std", penalty = 5.5),
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "noChange", state2 = "noChange", type = "null")
)
# Load required libraries
library(gfpop)
library(ggplot2)
# Define the plotModel function
plotModel <- function(graph) {
# Extract the edges from the gfpop::graph object using the correct method
edges <- as.data.frame(graph)
# Check if edges exist in the graph
if (nrow(edges) == 0) {
stop("The graph has no edges to plot.")
}
# Get all unique states (state1 and state2)
states <- unique(c(edges$state1, edges$state2))
# Create a node data frame with unique states
nodes <- data.frame(
state = states,
id = seq_along(states)
)
# Add x and y coordinates for nodes
nodes$y <- nodes$id
nodes$x <- 1
# Match edges with node positions
edges_plot <- merge(edges, nodes, by.x = "state1", by.y = "state")
colnames(edges_plot)[colnames(edges_plot) == "x"] <- "x_start"
colnames(edges_plot)[colnames(edges_plot) == "y"] <- "y_start"
edges_plot <- merge(edges_plot, nodes, by.x = "state2", by.y = "state")
colnames(edges_plot)[colnames(edges_plot) == "x"] <- "x_end"
colnames(edges_plot)[colnames(edges_plot) == "y"] <- "y_end"
# Create the plot using ggplot2
ggplot() +
# Add edges as arrows
geom_segment(
data = edges_plot,
aes(x = x_start, y = y_start, xend = x_end, yend = y_end, color = type),
arrow = arrow(length = unit(0.2, "cm"))
) +
# Add nodes as points
geom_point(
data = nodes,
aes(x = x, y = y),
color = "black",
size = 3
) +
# Add labels to nodes
geom_text(
data = nodes,
aes(x = x, y = y, label = state),
vjust = -1
) +
# Customize the theme
theme_minimal() +
labs(
x = "Position",
y = "State",
title = "Graph Visualization"
) +
theme(panel.grid = element_blank())
}
# Define the simple_graph
simple_graph <- gfpop::graph(
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "normal", state2 = "normal", type = "std", penalty = 5.5),
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "noChange", state2 = "noChange", type = "null")
)
# Plot the simple_graph
plotModel(simple_graph)
# Define the simple_graph
simple_graph <- gfpop::graph(
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "normal", state2 = "normal", type = "std", penalty = 5.5),
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "noChange", state2 = "noChange", type = "null")
)
simple_graph$edges$rule <- c(1, 1, 2, 2)
simple_graph
LOPART_graph <- gfpop::graph(
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "normal", state2 = "normal", type = "std", penalty = 5.5),
Edge(state1 = "normal", state2 = "normal", type = "null"),
Edge(state1 = "noChange", state2 = "noChange", type = "null"),
Edge(state1 = "normal", state2 = "noChange", type = "std"),
Edge(state1 = "normal", state2 = "normal", type = "std"),
Edge(state1 = "noChange", state2 = "normal", type = "null"),
Edge(state1 = "normal", state2 = "normal", type = "null")
)
LOPART_graph$edges$rule <- c(1, 1, 2, 2, 2, 3, 3, 4)
LOPART_graph
# Plot the simple_graph
plotModel(simple_graph)
install.packages("hyperSpec")
library(rextendr)
library(usethis)
usethis::create_package("matrixrowsum")
setwd("matrixrowsum")
rextendr::use_extendr()
install.packages(".", repos = NULL, type = "source")
library(matrixrowsum)
test_matrixrowsum("row_sums_rust computes correct row sums", {
# Create a test matrix
mat <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE)
# Compute row sums using Rust
result <- row_sums_rust(mat)
# Expected: row 1 sum = 1+2+3 = 6, row 2 sum = 4+5+6 = 15
expect_equal(result, c(6, 15))
})
test_matrixrowsum("row_sums_rust matches R's rowSums", {
# Create a random matrix
set.seed(42)
mat <- matrix(rnorm(100), nrow = 10, ncol = 10)
# Compare with R's built-in rowSums
result_rust <- row_sums_rust(mat)
result_r <- rowSums(mat)
expect_equal(result_rust, result_r, tolerance = 1e-10)
})
test_matrixrowsum("row_sums_rust handles single column matrix", {
mat <- matrix(c(1.5, 2.5, 3.5), nrow = 3, ncol = 1)
result <- row_sums_rust(mat)
expect_equal(result, c(1.5, 2.5, 3.5))
})
test_matrixrowsum("row_sums_rust handles single row matrix", {
mat <- matrix(c(1, 2, 3, 4), nrow = 1, ncol = 4)
result <- row_sums_rust(mat)
expect_equal(result, c(10))
})
# test
library(testthat)
test_file("test_matrixrowsum.R")
# test
library(testthat)
test_file("test_matrixrowsum.R")
test_check("matrixrowsum")
library(rextendr)
library(usethis)
usethis::create_package("matrixrowsum")
# check the package can be used
library(matrixrowsum)
# test
library(testthat)
test_file("test_matrixrowsum.R")
# check the package can be used
library(matrixrowsum)
matrixrowsum::rows_sums_rust()
